{
    "all_rules": {
        "rule_0": {
            "rule": "If the idx of the target search result exceeds 3 (the number of results per page), use 'turn_to_next_page' method as shown in the example.",
            "type": "Useful Helper Method",
            "example": "# Turn to the next page.\ndef turn_to_next_page(agent):\n  next_page_xpath = f\"//*[@id='pagination']/li[@class='page-item next']\"\n  html_string = agent.click_xpath(next_page_xpath)\n  return html_string\n",
            "validation_record": "Essential helper method provided by User."
        },
        "rule_1": {
            "rule": "If the task requires using a search engine, first click <input> textbox, type the target string, and then click \"Search\" button. If the target index exceeds 3, use 'turn_to_next_page' to turn the page. Otherwise, click the target result on the current page.",
            "type": "Success Process",
            "example": "# For example, to search \"Tora\" and click the 2nd result:\n# [Step 1] Find <input> textbox and type \"Tora\".\n# [Step 2] Click the search button.\n# [Step 3] Click the target result on the current page if it's within the first three results.\n# [Optional Step] Use 'turn_to_next_page' method to turn the page if the target index exceeds 3 and click the target result.\n",
            "validation_record": "Provided by User. | Updated based on the success of epoch_2 where the target result was on the first page."
        },
        "rule_2": {
            "rule": "To click on a search result that is not on the first page, navigate to the correct page using the 'turn_to_next_page' method and then verify the actual `data-result` values before using the correct XPath that reflects the indexing of search results. Ensure the XPath reflects the actual `data-result` values observed on the page, rather than assuming continuous indexing.",
            "type": "Success Process",
            "example": "\n    # [Step 1] Click the input textbox and type the search term.\n    # [Step 2] Click the search button.\n    # [Step 3] Use 'turn_to_next_page' method to navigate to the correct page.\n    # [Step 4] Verify the actual `data-result` values before clicking on the desired search result.\n    # Incorrect XPath assumption: result_xpath = f\"//*[@id='page-content']//a[@data-result='0']\"\n    # Corrected XPath after verification: result_xpath = f\"//*[@id='page-content']//a[@data-result='4']\"\n    ",
            "validation_record": "Based on the agent's experience in epoch_0_interact_2 and epoch_0_interact_3. | Updated based on the agent's experience in epoch_1_interact_3, where the initial assumption about `data-result` indexing was incorrect. | Based on the agent's corrected action in epoch_1_interact_3."
        },
        "rule_3": {
            "rule": "When playing tic-tac-toe, use the 'click_cell' helper method to click on a cell by its ID.",
            "type": "Useful Helper Method",
            "example": "# Helper method to click on a cell in the tic-tac-toe board\ndef click_cell(agent, cell_id):\n    cell_xpath = f\"//*[@id='{cell_id}']\"\n    return agent.click_xpath(cell_xpath)\n",
            "validation_record": "The 'click_cell' method was successfully used to interact with the tic-tac-toe board in epoch_3."
        },
        "rule_4": {
            "rule": "To win a game of tic-tac-toe as 'X', follow a strategic sequence of moves, starting with the center, then corners, and finally completing a line based on the opponent's moves. Ensure to verify the winning condition before making the final move. Additionally, always be prepared to make defensive moves to block the opponent's potential winning lines. *Prioritize blocking the opponent's immediate winning opportunities if they arise.* Use helper methods 'parse_board_state' and 'find_move' to assess the board and determine the best move.",
            "type": "Success Process",
            "example": "# Helper function to parse the board and find the state of each cell\ndef parse_board_state(html_string):\n    # ... (existing code)\n\n# Helper function to find a winning or blocking move\ndef find_move(board_state, mark):\n    # ... (existing code)\n\n# ... (rest of the success process as in the successful code)",
            "validation_record": "Updated based on the failure in epoch_27 where the agent did not block the opponent's winning move. | Updated based on the success of epoch_28 where the agent followed a specific sequence of moves to win the game. | Updated based on the success of epoch_29 where the agent used additional helper methods to win the game."
        },
        "rule_5": {
            "rule": "When forwarding an email, use the 'forward_email' helper method to encapsulate the process, which involves opening the email, clicking the forward option, entering the recipient's name, and sending the email. Be aware of dynamic content changes such as new HTML elements for forwarding options and recipient fields.",
            "type": "Success Process",
            "example": "# Helper method to forward an email to a specified recipient\ndef forward_email(agent, sender_name, recipient_name):\n    # [Step 1] Locate the email thread with the sender's name.\n    sender_email_xpath = f\"//*[@class='email-sender' and text()='{sender_name}']\"\n    html_string = agent.click_xpath(sender_email_xpath)\n    # Pause here to ensure that the email interface has opened and the forward option is available.\n    \n    # [Step 2] Click the \"Forward\" option within the opened email.\n    forward_xpath = \"//*[@class='email-forward']\"\n    html_string = agent.click_xpath(forward_xpath)\n    # Pause here to ensure that the forwarding interface is visible and the recipient field is available.\n    \n    # [Step 3] Type the recipient's name into the recipient field.\n    recipient_field_xpath = \"//*[@class='forward-sender']\"\n    html_string = agent.click_xpath(recipient_field_xpath)\n    html_string = agent.type(recipient_name)\n    \n    # [Step 4] Click the send button to forward the email.\n    send_button_xpath = \"//*[@id='send-forward']\"\n    html_string = agent.click_xpath(send_button_xpath)\n    # No need to pause here as this is the final action to complete the task.\n",
            "validation_record": "Updated based on the successful completion of the email forwarding task in epoch_8, 19, 23. | The 'forward_email' method was successfully used to forward an email in epoch_23. | Observed in epoch_6 where clicking on the email and forwarding option resulted in new HTML elements."
        },
        "rule_6": {
            "rule": "When interacting with a simulated terminal on a web page, type commands directly without attempting to click on any elements to focus. Before using 'list_files_with_extension' or 'delete_file_with_extension', verify that these helper methods are defined in the current environment. If not, proceed with manual command input.",
            "type": "Success Process",
            "example": "\n    # [Step 1] Type the command to list all files with the specified extension.\n    list_files_command = \"ls *.extension\"\n    agent.type(list_files_command)\n    agent.press_key(\"enter\")\n    \n    # [Step 2] Observe the output to identify the file name.\n    # [Step 3] Type the command to delete the identified file.\n    delete_file_command = \"rm filename.extension\"\n    agent.type(delete_file_command)\n    agent.press_key(\"enter\")\n    \n\n\n    # Helper method to list files with a specified extension in a simulated terminal environment.\n    def list_files_with_extension(agent, extension):\n        list_files_command = f\"ls *{extension}\"\n        agent.type(list_files_command)\n        agent.press_key(\"enter\")\n    \n    # Helper method to delete a file with a specified extension in a simulated terminal environment.\n    def delete_file_with_extension(agent, filename_with_extension):\n        delete_file_command = f\"rm {filename_with_extension}\"\n        agent.type(delete_file_command)\n        agent.press_key(\"enter\")\n    # Incorrect approach: Attempting to use an undefined helper method\n    list_files_with_extension(agent, \".png\")  # This will fail if the method is not defined\n    \n    # Correct approach: Directly type the command into the terminal\n    list_files_command = \"ls *.png\"\n    agent.type(list_files_command)\n    agent.press_key(\"enter\")",
            "validation_record": "Based on the successful use of these methods in epoch_10. | Updated based on the agent's experience in epoch_11 where the helper methods were not defined. | Based on the corrected action in epoch_11 after the initial error."
        },
        "rule_7": {
            "rule": "After any action that could potentially change the state of form elements, such as closing a popup or alert, verify that the input fields and buttons are enabled and interactable before proceeding. This ensures that the elements are ready for interaction and prevents errors related to disabled elements. Always re-verify the interactability of form elements after closing popups or other UI elements that may affect their state.",
            "type": "Corrected Error",
            "example": "\n    # Incorrect approach: Not verifying the state of form elements after closing a popup.\n    # Correct approach: After closing a popup or alert, re-verify that the input fields and buttons are enabled and interactable before proceeding.\n    # [Step 1] Close the popup by clicking the \"Cancel\" button.\n    # [Step 2] Re-verify that the input fields and login button are enabled and interactable.\n    # [Step 3] Proceed with typing the password and clicking the login button.\n",
            "validation_record": "Based on the corrected action in epoch_32 where the agent initially failed to type into a disabled password field and then successfully completed the task after re-verifying the state of the form elements. | Based on the failure in epoch_14 where the agent did not verify the state of the form elements after closing a popup. | Updated based on the failure in epoch_32 where the agent did not verify the state of the form elements after closing a popup."
        },
        "rule_8": {
            "rule": "When logging into a web form, click on the username input field and type the username, then click on the password input field and type the password. Before clicking on the login button to submit the form, verify that the input fields and button are enabled and interactable. Additionally, after closing a popup or other UI elements that may disable form elements, re-verify that the input fields and button are enabled and interactable before proceeding.",
            "type": "Success Process",
            "example": "\n    # [Step 1] Click on the username input field and type the username.\n    # [Step 2] Click on the password input field and type the password.\n    # [Verification Step] Verify that the input fields and login button are enabled and interactable.\n    # [Step 3] Click on the login button to submit the form.\n    # [Additional Verification Step] After closing a popup or other UI elements that may disable form elements, re-verify that the input fields and button are enabled and interactable before proceeding.\n    ",
            "validation_record": "Based on the successful login process in epoch_12. | Updated based on the failure in epoch_14 where the input fields were disabled. | Updated based on the experience in epoch_32 where the agent failed to type into a disabled password field and did not re-verify the state of the form elements after closing a popup."
        },
        "rule_9": {
            "rule": "When engaging in a guessing game, initialize a guess to the middle of the range, submit it, and use feedback to iteratively adjust the guess. Ensure to clear the input field before each new guess.",
            "type": "Success Process",
            "example": "# [Step 1] Initialize the guess to the middle of the range (0-9), which is 4.\n# [Step 2] Click on the input field and type the initial guess.\n# [Step 3] Click the \"Submit\" button to submit the guess.\n# Pause here to observe the feedback and plan the next steps based on it.\n# Based on the feedback, if the number is lower than the guess, adjust the upper bound and guess again.\n# If the number is higher than the guess, adjust the lower bound and guess again.\n# Repeat steps 4-7 as necessary, adjusting the guess based on the feedback.\n# [Step 4] Clear the input field before typing the new guess.\n# [Step 5] Adjust the guess to the middle of the new range, which is 7.\n# [Step 6] Click on the input field and type the new guess.\n# [Step 7] Click the \"Submit\" button to submit the new guess.\n# Pause here to observe the feedback and plan the next steps based on it.\n# If the feedback indicates the guess is correct, the task is completed.\n# If not, continue adjusting the guess based on the feedback and repeat steps 8-11.\n# Since the feedback indicates the number is higher than 8, the next guess must be 9.\n# [Step 8] Clear the input field before typing the new guess.\n# [Step 9] Since the number is higher than 8, the next guess must be 9.\n# [Step 10] Click on the input field and type the final guess.\n# [Step 11] Click the \"Submit\" button to submit the final guess.\n# This should complete the task as 9 is the only number left in the range.\n# No need to pause here as this is the final action to complete the task.",
            "validation_record": "Further validated by the successful completion of the guessing game task in epoch_33. | Updated based on the successful completion of the guessing game task in epoch_34. | Updated based on the success of epoch_35."
        },
        "rule_10": {
            "rule": "Use the 'clear_input_field' method to clear the input field before typing a new guess in a guessing game, tailoring the number of backspace presses to the actual length of the input to conserve steps.",
            "type": "Useful Helper Method",
            "example": "\n# Helper method to clear the input field\ndef clear_input_field(agent, input_xpath, current_value):\n    agent.click_xpath(input_xpath)\n    for _ in range(len(str(current_value))):  # Clear the current value\n        agent.press_key(\"backspace\")\n# Incorrect approach: Not clearing the input field before typing the new guess\n# Corrected approach: Clear the input field before typing the new guess\n\n\n# Inefficient clearing of the input field:\nfor _ in range(10):  # Clear the current value (0-9)\n    agent.press_key(\"backspace\")\n# This approach may lead to exceeding the step limit.\n",
            "validation_record": "The need to clear the input field was identified and corrected in epoch_15. | Observed in epoch_16 where the agent exceeded the step limit due to inefficient input clearing. | Further validated by the successful use in epoch_33."
        },
        "rule_11": {
            "rule": "In environments with a step limit, the agent must optimize each action to minimize the number of steps used to avoid exceeding the limit.",
            "type": "Special Phenomena/Mechanism",
            "example": "",
            "validation_record": "The step limit was a critical factor in the failure of epoch_16."
        },
        "rule_12": {
            "rule": "When interacting with an email, locate the email by the sender's name and click the appropriate icon (star to mark as important, trash to delete) within the email thread.",
            "type": "Success Process",
            "example": "# [Step 1] Locate the email thread with the sender 'Stepha'.\nstepha_email_xpath = \"//*[@class='email-sender' and text()='Stepha']\"\n\n# [Step 2] Find the trash icon within the located email thread.\ntrash_icon_xpath = f\"{stepha_email_xpath}/ancestor::div[contains(@class, 'email-thread')]//*[@class='trash']\"\n\n# [Step 3] Click the trash icon to delete the email.\nhtml_string = agent.click_xpath(trash_icon_xpath)\n",
            "validation_record": "Based on the successful completion of the task in epoch_21. | Updated based on the successful completion of the task in epoch_22. | Further validated by the successful completion of the task in epoch_26."
        }
    },
    "cur_epoch": 0,
    "manual": "# Web Page Agent Interaction Manual\n\n## Overview\n\nThis manual provides a comprehensive set of rules for a web page agent to interact with various elements and complete tasks within a web environment. The rules cover navigation, game strategies, email and terminal interactions, form handling, and step optimization.\n\n## Navigation and Search\n\n### Introduction\n\nThis category includes rules for navigating search results and handling pagination.\n\n#### Included Rules\n\n- rule_0 (score=5): If the idx of the target search result exceeds 3 (the number of results per page), use 'turn_to_next_page' method as shown in the example. For example, # Turn to the next page.\ndef turn_to_next_page(agent):\n  next_page_xpath = f\"//*[@id='pagination']/li[@class='page-item next']\"\n  html_string = agent.click_xpath(next_page_xpath)\n  return html_string\n\n\n- rule_1 (score=5): If the task requires using a search engine, first click <input> textbox, type the target string, and then click \"Search\" button. If the target index exceeds 3, use 'turn_to_next_page' to turn the page. Otherwise, click the target result on the current page. For example, # For example, to search \"Tora\" and click the 2nd result:\n# [Step 1] Find <input> textbox and type \"Tora\".\n# [Step 2] Click the search button.\n# [Step 3] Click the target result on the current page if it's within the first three results.\n# [Optional Step] Use 'turn_to_next_page' method to turn the page if the target index exceeds 3 and click the target result.\n\n\n- rule_2 (score=4): To click on a search result that is not on the first page, navigate to the correct page using the 'turn_to_next_page' method and then verify the actual `data-result` values before using the correct XPath that reflects the indexing of search results. Ensure the XPath reflects the actual `data-result` values observed on the page, rather than assuming continuous indexing. For example, \n    # [Step 1] Click the input textbox and type the search term.\n    # [Step 2] Click the search button.\n    # [Step 3] Use 'turn_to_next_page' method to navigate to the correct page.\n    # [Step 4] Verify the actual `data-result` values before clicking on the desired search result.\n    # Incorrect XPath assumption: result_xpath = f\"//*[@id='page-content']//a[@data-result='0']\"\n    # Corrected XPath after verification: result_xpath = f\"//*[@id='page-content']//a[@data-result='4']\"\n    \n\n\n## Game Strategy and Interaction\n\n### Introduction\n\nRules in this category provide strategies for playing games like tic-tac-toe and interacting with game elements.\n\n#### Included Rules\n\n- rule_3 (score=3): When playing tic-tac-toe, use the 'click_cell' helper method to click on a cell by its ID. For example, # Helper method to click on a cell in the tic-tac-toe board\ndef click_cell(agent, cell_id):\n    cell_xpath = f\"//*[@id='{cell_id}']\"\n    return agent.click_xpath(cell_xpath)\n\n\n- rule_4 (score=5): To win a game of tic-tac-toe as 'X', follow a strategic sequence of moves, starting with the center, then corners, and finally completing a line based on the opponent's moves. Ensure to verify the winning condition before making the final move. Additionally, always be prepared to make defensive moves to block the opponent's potential winning lines. *Prioritize blocking the opponent's immediate winning opportunities if they arise.* Use helper methods 'parse_board_state' and 'find_move' to assess the board and determine the best move. For example, # Helper function to parse the board and find the state of each cell\ndef parse_board_state(html_string):\n    # ... (existing code)\n\n# Helper function to find a winning or blocking move\ndef find_move(board_state, mark):\n    # ... (existing code)\n\n# ... (rest of the success process as in the successful code)\n\n- rule_5 (score=3): Use the 'parse_board_state' method to parse the current state of the tic-tac-toe board and the 'find_move' method to find winning or blocking moves. For example, # Helper function to parse the board and find the state of each cell\ndef parse_board_state(html_string):\n    # ... (existing code)\n\n# Helper function to find a winning or blocking move\ndef find_move(board_state, mark):\n    # ... (existing code)\n\n\n## Email Interaction\n\n### Introduction\n\nThis category contains rules for performing email-related tasks such as forwarding.\n\n#### Included Rules\n\n- rule_6 (score=5): When forwarding an email, use the 'forward_email' helper method to encapsulate the process, which involves opening the email, clicking the forward option, entering the recipient's name, and sending the email. Be aware of dynamic content changes such as new HTML elements for forwarding options and recipient fields. For example, # Helper method to forward an email to a specified recipient\ndef forward_email(agent, sender_name, recipient_name):\n    # [Step 1] Locate the email thread with the sender's name.\n    sender_email_xpath = f\"//*[@class='email-sender' and text()='{sender_name}']\"\n    html_string = agent.click_xpath(sender_email_xpath)\n    # Pause here to ensure that the email interface has opened and the forward option is available.\n    \n    # [Step 2] Click the \"Forward\" option within the opened email.\n    forward_xpath = \"//*[@class='email-forward']\"\n    html_string = agent.click_xpath(forward_xpath)\n    # Pause here to ensure that the forwarding interface is visible and the recipient field is available.\n    \n    # [Step 3] Type the recipient's name into the recipient field.\n    recipient_field_xpath = \"//*[@class='forward-sender']\"\n    html_string = agent.click_xpath(recipient_field_xpath)\n    html_string = agent.type(recipient_name)\n    \n    # [Step 4] Click the send button to forward the email.\n    send_button_xpath = \"//*[@id='send-forward']\"\n    html_string = agent.click_xpath(send_button_xpath)\n    # No need to pause here as this is the final action to complete the task.\n\n\n\n## Terminal Interaction\n\n### Introduction\n\nRules for interacting with a simulated terminal on a web page.\n\n#### Included Rules\n\n- rule_7 (score=4): When interacting with a simulated terminal on a web page, type commands directly without attempting to click on any elements to focus. Before using 'list_files_with_extension' or 'delete_file_with_extension', verify that these helper methods are defined in the current environment. If not, proceed with manual command input. For example, \n    # [Step 1] Type the command to list all files with the specified extension.\n    list_files_command = \"ls *.extension\"\n    agent.type(list_files_command)\n    agent.press_key(\"enter\")\n    \n    # [Step 2] Observe the output to identify the file name.\n    # [Step 3] Type the command to delete the identified file.\n    delete_file_command = \"rm filename.extension\"\n    agent.type(delete_file_command)\n    agent.press_key(\"enter\")\n    \n\n\n    # Helper method to list files with a specified extension in a simulated terminal environment.\n    def list_files_with_extension(agent, extension):\n        list_files_command = f\"ls *{extension}\"\n        agent.type(list_files_command)\n        agent.press_key(\"enter\")\n    \n    # Helper method to delete a file with a specified extension in a simulated terminal environment.\n    def delete_file_with_extension(agent, filename_with_extension):\n        delete_file_command = f\"rm {filename_with_extension}\"\n        agent.type(delete_file_command)\n        agent.press_key(\"enter\")\n    # Incorrect approach: Attempting to use an undefined helper method\n    list_files_with_extension(agent, \".png\")  # This will fail if the method is not defined\n    \n    # Correct approach: Directly type the command into the terminal\n    list_files_command = \"ls *.png\"\n    agent.type(list_files_command)\n    agent.press_key(\"enter\")\n\n\n## Form Interaction\n\n### Introduction\n\nRules for interacting with web forms, including login processes and element state verification.\n\n#### Included Rules\n\n- rule_8 (score=4): After any action that could potentially change the state of form elements, such as closing a popup or alert, verify that the input fields and buttons are enabled and interactable before proceeding. This ensures that the elements are ready for interaction and prevents errors related to disabled elements. Always re-verify the interactability of form elements after closing popups or other UI elements that may affect their state. For example, \n    # Incorrect approach: Not verifying the state of form elements after closing a popup.\n    # Correct approach: After closing a popup or alert, re-verify that the input fields and buttons are enabled and interactable before proceeding.\n    # [Step 1] Close the popup by clicking the \"Cancel\" button.\n    # [Step 2] Re-verify that the input fields and login button are enabled and interactable.\n    # [Step 3] Proceed with typing the password and clicking the login button.\n\n\n- rule_9 (score=4): When logging into a web form, click on the username input field and type the username, then click on the password input field and type the password. Before clicking on the login button to submit the form, verify that the input fields and button are enabled and interactable. Additionally, after closing a popup or other UI elements that may disable form elements, re-verify that the input fields and button are enabled and interactable before proceeding. For example, \n    # [Step 1] Click on the username input field and type the username.\n    # [Step 2] Click on the password input field and type the password.\n    # [Verification Step] Verify that the input fields and login button are enabled and interactable.\n    # [Step 3] Click on the login button to submit the form.\n    # [Additional Verification Step] After closing a popup or other UI elements that may disable form elements, re-verify that the input fields and button are enabled and interactable before proceeding.\n    \n\n\n## Guessing Game Strategy\n\n### Introduction\n\nStrategies for engaging in and succeeding at guessing games.\n\n#### Included Rules\n\n- rule_10 (score=5): When engaging in a guessing game, initialize a guess to the middle of the range, submit it, and use feedback to iteratively adjust the guess. Ensure to clear the input field before each new guess. For example, # [Step 1] Initialize the guess to the middle of the range (0-9), which is 4.\n# [Step 2] Click on the input field and type the initial guess.\n# [Step 3] Click the \"Submit\" button to submit the guess.\n# Pause here to observe the feedback and plan the next steps based on it.\n# Based on the feedback, if the number is lower than the guess, adjust the upper bound and guess again.\n# If the number is higher than the guess, adjust the lower bound and guess again.\n# Repeat steps 4-7 as necessary, adjusting the guess based on the feedback.\n# [Step 4] Clear the input field before typing the new guess.\n# [Step 5] Adjust the guess to the middle of the new range, which is 7.\n# [Step 6] Click on the input field and type the new guess.\n# [Step 7] Click the \"Submit\" button to submit the new guess.\n# Pause here to observe the feedback and plan the next steps based on it.\n# If the feedback indicates the guess is correct, the task is completed.\n# If not, continue adjusting the guess based on the feedback and repeat steps 8-11.\n# Since the feedback indicates the number is higher than 8, the next guess must be 9.\n# [Step 8] Clear the input field before typing the new guess.\n# [Step 9] Since the number is higher than 8, the next guess must be 9.\n# [Step 10] Click on the input field and type the final guess.\n# [Step 11] Click the \"Submit\" button to submit the final guess.\n# This should complete the task as 9 is the only number left in the range.\n# No need to pause here as this is the final action to complete the task.\n\n- rule_11 (score=4): Use the 'clear_input_field' method to clear the input field before typing a new guess in a guessing game, tailoring the number of backspace presses to the actual length of the input to conserve steps. For example, \n# Helper method to clear the input field\ndef clear_input_field(agent, input_xpath, current_value):\n    agent.click_xpath(input_xpath)\n    for _ in range(len(str(current_value))):  # Clear the current value\n        agent.press_key(\"backspace\")\n# Incorrect approach: Not clearing the input field before typing the new guess\n# Corrected approach: Clear the input field before typing the new guess\n\n\n# Inefficient clearing of the input field:\nfor _ in range(10):  # Clear the current value (0-9)\n    agent.press_key(\"backspace\")\n# This approach may lead to exceeding the step limit.\n\n\n\n## Helper Methods\n\n### Introduction\n\nRules that define and encourage the use of helper methods to simplify tasks.\n\n#### Included Rules\n\n- rule_0: Helper method for pagination.\n- rule_3: Helper method for tic-tac-toe cell clicking.\n- rule_6: Helper method for forwarding emails.\n- rule_11: Helper method for clearing input fields.\n- rule_5: Helper methods for parsing board state and finding moves.\n\n## Step Optimization\n\n### Introduction\n\nRules that focus on minimizing the number of steps taken to complete tasks, especially important in environments with step limits.\n\n#### Included Rules\n\n- rule_12 (score=3): In environments with a step limit, the agent must optimize each action to minimize the number of steps used to avoid exceeding the limit.\n\n\n## Miscellaneous Interactions\n\n### Introduction\n\nRules for miscellaneous tasks such as interacting with emails and handling specific UI elements.\n\n#### Included Rules\n\n- rule_13 (score=4): When interacting with an email, locate the email by the sender's name and click the appropriate icon (star to mark as important, trash to delete) within the email thread. For example, # [Step 1] Locate the email thread with the sender 'Stepha'.\nstepha_email_xpath = \"//*[@class='email-sender' and text()='Stepha']\"\n\n# [Step 2] Find the trash icon within the located email thread.\ntrash_icon_xpath = f\"{stepha_email_xpath}/ancestor::div[contains(@class, 'email-thread')]//*[@class='trash']\"\n\n# [Step 3] Click the trash icon to delete the email.\nhtml_string = agent.click_xpath(trash_icon_xpath)\n\n"
}